
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.io.TextIO;
import org.apache.beam.sdk.testing.PAssert;
import org.apache.beam.sdk.testing.TestPipeline;
import org.apache.beam.sdk.values.PCollection;
import org.junit.Rule;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.File;
import java.io.FileWriter;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertNotNull;

public class RepeatUseDailyNormTest {

    @TempDir
    Path tempDir;

    // Optional if you want to use @Rule style (JUnit 4 compatibility)
    @Rule
    public final transient TestPipeline testPipeline = TestPipeline.create();

    @Test
    void testCreatePipelineReadsFileWithTestPipeline() throws Exception {
        // Step 1: Prepare test input file
        File testFile = tempDir.resolve("test-input.txt").toFile();
        try (FileWriter writer = new FileWriter(testFile)) {
            writer.write("first\nsecond\nthird\n");
        }

        // Step 2: Mock the LogErrorFileUtility
        LogErrorFileUtility mockLogUtil = Mockito.mock(LogErrorFileUtility.class);

        // Step 3: Use TestPipeline directly
        Pipeline pipeline = TestPipeline.create();

        // Step 4: Apply read
        PCollection<String> output = pipeline.apply(
                "READ_HOTORU_FILE", TextIO.read().from(testFile.getAbsolutePath())
        );

        // Step 5: Assert
        PAssert.that(output).containsInAnyOrder("first", "second", "third");

        pipeline.run().waitUntilFinish();
    }

    @Test
    void testMainRunsWithoutErrors() {
        assertDoesNotThrow(() -> Test.main(new String[]{}));
    }

    @Test
    void testCreatePipelineReturnsNonNullPipeline() {
        LogErrorFileUtility mockLogUtil = Mockito.mock(LogErrorFileUtility.class);
        Pipeline pipeline = Test.createPipeline(mockLogUtil, "/dummy/path.txt");
        assertNotNull(pipeline);
    }
}



import org.apache.beam.sdk.testing.PAssert;
import org.apache.beam.sdk.testing.TestPipeline;
import org.apache.beam.sdk.transforms.Filter;
import org.apache.beam.sdk.io.FileSystems;
import org.apache.beam.sdk.io.fs.MatchResult;
import org.apache.beam.sdk.io.TextIO;
import org.apache.beam.sdk.transforms.Create;
import org.apache.beam.sdk.values.PCollection;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.coders.StringUtf8Coder;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.MockedStatic;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class FileReaderPipelineTest {

    @Rule
    public final transient TestPipeline pipeline = TestPipeline.create();

    @Test
    public void testCreatePipeline_FileExists_FiltersHeaderLines() throws IOException {
        String mockPath = "mock/input.txt";
        List<String> mockLines = Arrays.asList("Header1", "Body", "Header2", "Trailer");

        // Mocking FileSystems.matchSingleFileSpec
        try (MockedStatic<FileSystems> fsMock = mockStatic(FileSystems.class)) {
            MatchResult.Metadata mockMeta = mock(MatchResult.Metadata.class);
            fsMock.when(() -> FileSystems.matchSingleFileSpec(mockPath)).thenReturn(mockMeta);

            // Instead of real TextIO, mock with Create.of
            PCollection<String> input = pipeline.apply(Create.of(mockLines).withCoder(StringUtf8Coder.of()));
            PCollection<String> filtered = input.apply(Filter.by(line -> line != null && line.trim().startsWith("H")));

            PAssert.that(filtered).containsInAnyOrder("Header1", "Header2");
            pipeline.run().waitUntilFinish();
        }
    }

    @Test(expected = FileNotFoundException.class)
    public void testCreatePipeline_FileDoesNotExist_ThrowsException() throws IOException {
        String mockPath = "nonexistent.txt";

        try (MockedStatic<FileSystems> fsMock = mockStatic(FileSystems.class)) {
            fsMock.when(() -> FileSystems.matchSingleFileSpec(mockPath)).thenReturn(null);

            Pipeline testPipe = Pipeline.create();
            FileReaderPipeline.createPipeline(testPipe, mockPath);
        }
    }
}


import org.apache.beam.sdk.transforms.DoFn;
import org.apache.beam.sdk.values.TupleTag;
import org.apache.beam.sdk.values.KV;
import org.apache.beam.sdk.values.Row;
import org.apache.beam.sdk.transforms.DoFnTester;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

public class RepeatUseNormalizationConversionTest {

    private RepeatUseNormalizationConversion fn;
    private TupleTag<String> logTag;
    private TupleTag<Row> validTag;

    @BeforeEach
    public void setup() {
        logTag = new TupleTag<>();
        validTag = new TupleTag<>();
        fn = new RepeatUseNormalizationConversion(logTag, validTag);
    }

    @Test
    public void testValidInput() throws Exception {
        Map<String, Object> values = new HashMap<>();
        values.put("HOTROU-ACCOUNT-NBR", "123456789");
        values.put("HOTROU-REPT-USE-IND-1", "Y");
        values.put("HOTROU-REPT-USE-DATE-1", "20230501");
        values.put("HOTROU-REPT-USE-IND-2", "N");
        values.put("HOTROU-REPT-USE-DATE-2", "20230502");
        values.put("HOTROU-REPT-USE-IND-3", "Y");
        values.put("HOTROU-REPT-USE-DATE-3", "20230503");
        values.put("HOTROU-REPT-USE-HISTORY", "Some history");

        Row inputRow = Row.withSchema(RepeatUseSchema.ROW_SCHEMA).addValues(
                values.get("HOTROU-ACCOUNT-NBR"),
                values.get("HOTROU-REPT-USE-IND-1"),
                values.get("HOTROU-REPT-USE-DATE-1"),
                values.get("HOTROU-REPT-USE-IND-2"),
                values.get("HOTROU-REPT-USE-DATE-2"),
                values.get("HOTROU-REPT-USE-IND-3"),
                values.get("HOTROU-REPT-USE-DATE-3"),
                values.get("HOTROU-REPT-USE-HISTORY")
        ).build();

        DoFnTester<Row, Row> tester = DoFnTester.of(fn);
        tester.processElement(inputRow);

        assertEquals(1, tester.peekOutput(validTag).size());
        assertTrue(tester.peekOutput(logTag).isEmpty());
    }

    @Test
    public void testInvalidAccountNumber() {
        Map<String, Object> values = new HashMap<>();
        values.put("HOTROU-ACCOUNT-NBR", "");
        values.put("HOTROU-REPT-USE-IND-1", "Y");
        values.put("HOTROU-REPT-USE-DATE-1", "20230501");

        Row inputRow = Row.withSchema(RepeatUseSchema.ROW_SCHEMA).addValues(
                values.get("HOTROU-ACCOUNT-NBR"),
                values.get("HOTROU-REPT-USE-IND-1"),
                values.get("HOTROU-REPT-USE-DATE-1"),
                "", "", "", "", ""
        ).build();

        DoFnTester<Row, Row> tester = DoFnTester.of(fn);
        tester.processElement(inputRow);

        assertEquals(0, tester.peekOutput(validTag).size());
        assertEquals(1, tester.peekOutput(logTag).size());
    }

    @Test
    public void testInvalidDateFormat() {
        Map<String, Object> values = new HashMap<>();
        values.put("HOTROU-ACCOUNT-NBR", "987654321");
        values.put("HOTROU-REPT-USE-IND-1", "Y");
        values.put("HOTROU-REPT-USE-DATE-1", "invalid-date");

        Row inputRow = Row.withSchema(RepeatUseSchema.ROW_SCHEMA).addValues(
                values.get("HOTROU-ACCOUNT-NBR"),
                values.get("HOTROU-REPT-USE-IND-1"),
                values.get("HOTROU-REPT-USE-DATE-1"),
                "", "", "", "", ""
        ).build();

        DoFnTester<Row, Row> tester = DoFnTester.of(fn);
        tester.processElement(inputRow);

        assertEquals(1, tester.peekOutput(validTag).size()); // with DEFAULT_DATE fallback
        assertFalse(tester.peekOutput(logTag).isEmpty());
    }
}



import static org.mockito.Mockito.*;

import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.testing.TestPipeline;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.MockedStatic;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.Logger;

@RunWith(MockitoJUnitRunner.class)
public class YourMainClassTest {

    @Rule
    public final TestPipeline testPipeline = TestPipeline.create();

    @Test
    public void testMainMethod() {
        try (
            MockedStatic<PipelineOptionsFactory> factoryMock = mockStatic(PipelineOptionsFactory.class);
            MockedStatic<Pipeline> pipelineMock = mockStatic(Pipeline.class)
        ) {
            CustomPipelineOptions mockOptions = mock(CustomPipelineOptions.class);
            Pipeline mockPipeline = mock(Pipeline.class);

            factoryMock.when(() -> PipelineOptionsFactory.create()).thenReturn(mockOptions);
            when(mockOptions.as(CustomPipelineOptions.class)).thenReturn(mockOptions);
            when(mockOptions.getInputFileName()).thenReturn("mock_input");
            when(mockOptions.getGcsInputFileBasePath()).thenReturn("mock_base_path");
            when(mockOptions.getOutputFileBasePath()).thenReturn("mock_output_path");
            when(mockOptions.getOutputFileName()).thenReturn("mock_file_name");

            pipelineMock.when(() -> Pipeline.create(mockOptions)).thenReturn(mockPipeline);
            when(mockPipeline.run()).thenReturn(testPipeline.run());

            YourMainClass.main(new String[]{});

            verify(mockPipeline.run()).waitUntilFinish();
        } catch (Exception e) {
            throw new AssertionError("Test failed", e);
        }
    }
}
