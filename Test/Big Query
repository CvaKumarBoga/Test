Write a big query as per below description

I have a transaction table fields account number and amount column and PTP agreement table fields account number and remaining amount and PTP id and PTP agreement table fields PTP id and account number and total amount so based on transaction amount need to update amount column in PTP aggreement table and PTP assignment table example 3000 transaction amount and if transaction is > PTP agreement table amount (1500)and PTP arrangement table PTP amount column (1500) need to subtract and remaining 1500 amount against substrate from next record so similarly if 2 transaction records for same account number need to subtract all two transactions amount from all PTP amount from agreement table and assignment table

-- Step 1: Sum total transaction amounts per account
WITH transaction_summary AS (
  SELECT
    account_number,
    SUM(amount) AS total_transaction_amount
  FROM
    transaction_table
  GROUP BY
    account_number
),

-- Step 2: Compute how much to deduct from ptp_agreement_table
ptp_agreement_update AS (
  SELECT
    p.ptp_id,
    p.account_number,
    p.remaining_amount,
    LEAST(p.remaining_amount, t.total_transaction_amount) AS amount_to_deduct,
    -- remaining transaction amount after deduction
    GREATEST(t.total_transaction_amount - p.remaining_amount, 0) AS remaining_txn_after_agreement
  FROM
    ptp_agreement_table p
  JOIN
    transaction_summary t
  ON
    p.account_number = t.account_number
),

-- Step 3: Compute how much to deduct from ptp_assignment_table using the remaining amount
ptp_assignment_update AS (
  SELECT
    pa.ptp_id,
    pa.account_number,
    pa.total_amount,
    LEAST(pa.total_amount, a.remaining_txn_after_agreement) AS amount_to_deduct
  FROM
    ptp_assignment_table pa
  JOIN
    ptp_agreement_update a
  ON
    pa.ptp_id = a.ptp_id
)

-- Final Select to show the updates
SELECT
  'ptp_agreement_table' AS table_name,
  ptp_id,
  account_number,
  remaining_amount AS original_amount,
  remaining_amount - amount_to_deduct AS updated_amount
FROM
  ptp_agreement_update

UNION ALL

SELECT
  'ptp_assignment_table' AS table_name,
  ptp_id,
  account_number,
  total_amount AS original_amount,
  total_amount - amount_to_deduct AS updated_amount
FROM
  ptp_assignment_update;





-- Input: Specific account numbers
WITH transaction_data AS (
  SELECT
    account_number,
    SUM(transaction_amount) AS total_transaction_amount
  FROM
    transaction
  WHERE
    account_number IN ('000004005205201678', '000004005205201679')
  GROUP BY
    account_number
),

arrangement_base AS (
  SELECT
    p.account_number,
    p.ptp_group_id,
    p.ptp_id,
    p.term_counter,
    p.promise_balance,
    p.total_payment_amount,
    p.status AS ptp_status,
    p.term,
    p.remaining_ptp_term_balance,
    t.total_transaction_amount AS total_txn_amt,
    t.total_transaction_amount AS txn_amt_remaining
  FROM
    promise_to_pay_arrangement p
  JOIN
    transaction_data t
  ON
    p.account_number = t.account_number
),

RECURSIVE arrangement_recursive AS (
  -- Anchor: start with lowest term_counter (1)
  SELECT
    account_number,
    ptp_group_id,
    ptp_id,
    term_counter,
    promise_balance,
    total_payment_amount,
    ptp_status,
    term,
    remaining_ptp_term_balance,
    total_txn_amt,
    txn_amt_remaining,
    -- Amount applied in this iteration
    CASE
      WHEN txn_amt_remaining >= remaining_ptp_term_balance THEN remaining_ptp_term_balance
      ELSE txn_amt_remaining
    END AS payment_applied
  FROM
    arrangement_base
  WHERE
    term_counter = 1

  UNION ALL

  -- Recursive step: process the next term_counter + 1
  SELECT
    b.account_number,
    b.ptp_group_id,
    b.ptp_id,
    b.term_counter,
    b.promise_balance,
    b.total_payment_amount,
    b.ptp_status,
    b.term,
    b.remaining_ptp_term_balance,
    r.total_txn_amt,
    
    -- Update remaining txn amount
    CASE
      WHEN r.txn_amt_remaining >= r.remaining_ptp_term_balance THEN r.txn_amt_remaining - r.remaining_ptp_term_balance
      ELSE 0
    END AS txn_amt_remaining,

    -- Compute this recordâ€™s payment
    CASE
      WHEN r.txn_amt_remaining >= r.remaining_ptp_term_balance THEN b.remaining_ptp_term_balance
      ELSE r.txn_amt_remaining
    END AS payment_applied

  FROM
    arrangement_base b
  JOIN
    arrangement_recursive r
  ON
    b.account_number = r.account_number
    AND b.term_counter = r.term_counter + 1
)

-- Final: Expected Arrangement and Agreement Result
, arrangement_result AS (
  SELECT
    account_number,
    ptp_group_id,
    ptp_id,
    term_counter,
    remaining_ptp_term_balance AS original_balance,
    payment_applied,
    remaining_ptp_term_balance - payment_applied AS expected_remaining_balance,
    CASE
      WHEN remaining_ptp_term_balance - payment_applied = 0 THEN 'K'  -- Fully paid
      ELSE ptp_status
    END AS expected_ptp_status
  FROM
    arrangement_recursive
),

agreement_result AS (
  -- Aggregate arrangement data to get agreement-level (Promise Balance) result
  SELECT
    a.account_number,
    SUM(a.remaining_ptp_term_balance) AS original_promise_balance,
    SUM(a.payment_applied) AS total_payment_applied,
    SUM(a.remaining_ptp_term_balance - a.payment_applied) AS expected_promise_balance,
    CASE
      WHEN SUM(a.remaining_ptp_term_balance - a.payment_applied) = 0 THEN 'K'
      ELSE MAX(p.ptp_status)
    END AS expected_agreement_status
  FROM
    arrangement_recursive a
  JOIN
    promise_to_pay_arrangement p
  ON
    a.account_number = p.account_number
    AND a.ptp_group_id = p.ptp_group_id
    AND a.term_counter = p.term_counter
  GROUP BY
    a.account_number
)

-- Final SELECT combining both arrangement and agreement expected results
SELECT
  ar.account_number,
  ar.ptp_group_id,
  ar.ptp_id,
  ar.term_counter,
  ar.original_balance,
  ar.payment_applied,
  ar.expected_remaining_balance,
  ar.expected_ptp_status,
  ag.original_promise_balance,
  ag.total_payment_applied,
  ag.expected_promise_balance,
  ag.expected_agreement_status
FROM
  arrangement_result ar
JOIN
  agreement_result ag
ON
  ar.account_number = ag.account_number
ORDER BY
  ar.account_number,
  ar.term_counter;




-- Step 1: Join all 3 tables
WITH transaction_data AS (
  SELECT DISTINCT
    t.account_number,
    t.transaction_amount,
    ppa.ptp_id,
    ppa.ptp_group_id,
    ppa.promise_balance,
    ppa.total_payment_amount,
    ppa.status AS agreement_status,
    ppa.term AS agreement_term,
    pta.term_counter,
    pta.remaining_ptp_term_balance,
    pta.payment_amount,
    pta.status AS arrangement_status,
    ROW_NUMBER() OVER (PARTITION BY t.account_number ORDER BY t.transaction_date) AS transaction_order
  FROM `hsbc-12208313-collukdev-dev.CTA_C48_UK_MIG_TEMP.transaction` t
  JOIN `hsbc-12208313-collukdev-dev.CTA_C48_UK_MIG_TEMP.promise_to_pay_agreement` ppa
    ON t.account_number = ppa.account_number
  JOIN `hsbc-12208313-collukdev-dev.CTA_C48_UK_MIG_TEMP.promise_to_pay_arrangement` pta
    ON ppa.ptp_id = pta.ptp_id
   AND ppa.account_number = pta.account_number
  WHERE t.account_number IN (
    '0000040052052014076',
    '0000040052052014077',
    '0000040052052014078'
  )
),

-- Step 2: Order transactions and arrangements
ordered_transactions AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY account_number ORDER BY transaction_order) AS txn_seq
  FROM transaction_data
),

ordered_arrangements AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY account_number, ptp_id ORDER BY term_counter) AS term_seq
  FROM transaction_data
),

-- Step 3: Recursive logic to apply each transaction to terms
RECURSIVE applied_payments AS (
  -- Anchor: apply first transaction to first term
  SELECT
    ot.account_number,
    ot.ptp_id,
    ot.ptp_group_id,
    ot.txn_seq,
    ot.term_seq,
    ot.transaction_amount AS txn_remaining,
    ot.remaining_ptp_term_balance,
    ot.term_counter,
    CASE
      WHEN ot.transaction_amount >= ot.remaining_ptp_term_balance THEN ot.remaining_ptp_term_balance
      ELSE ot.transaction_amount
    END AS applied_amount
  FROM ordered_transactions ot
  WHERE term_seq = 1 AND txn_seq = 1

  UNION ALL

  -- Recursive: apply remainder of transaction to next term or move to next transaction
  SELECT
    ap.account_number,
    ap.ptp_id,
    ap.ptp_group_id,

    -- If current term fully paid and remainder exists, stay on txn_seq and go to next term
    CASE
      WHEN ap.txn_remaining - ap.applied_amount > 0 AND oa.term_seq > ap.term_seq THEN ap.txn_seq
      ELSE ap.txn_seq + 1
    END AS txn_seq,

    oa.term_seq,
    CASE
      WHEN ap.txn_remaining - ap.applied_amount > 0 THEN ap.txn_remaining - ap.applied_amount
      ELSE ot.transaction_amount
    END AS txn_remaining,

    oa.remaining_ptp_term_balance,
    oa.term_counter,

    CASE
      WHEN ap.txn_remaining - ap.applied_amount >= oa.remaining_ptp_term_balance THEN oa.remaining_ptp_term_balance
      WHEN ap.txn_remaining - ap.applied_amount > 0 THEN ap.txn_remaining - ap.applied_amount
      ELSE ot.transaction_amount
    END AS applied_amount

  FROM applied_payments ap
  JOIN ordered_arrangements oa
    ON ap.account_number = oa.account_number
    AND ap.ptp_id = oa.ptp_id
    AND oa.term_seq = ap.term_seq + 1

  JOIN ordered_transactions ot
    ON ap.account_number = ot.account_number
    AND ap.txn_seq + 1 = ot.txn_seq
  WHERE ap.txn_remaining > 0
)

-- Step 4: Final aggregation per term and agreement
, term_results AS (
  SELECT
    account_number,
    ptp_id,
    ptp_group_id,
    term_counter,
    SUM(applied_amount) AS total_paid,
    MIN(remaining_ptp_term_balance) AS original_balance,
    MIN(remaining_ptp_term_balance) - SUM(applied_amount) AS expected_remaining_balance,
    CASE
      WHEN MIN(remaining_ptp_term_balance) - SUM(applied_amount) = 0 THEN 'K'
      ELSE 'A'
    END AS expected_status
  FROM applied_payments
  GROUP BY account_number, ptp_id, ptp_group_id, term_counter
),

agreement_summary AS (
  SELECT
    account_number,
    ptp_id,
    ptp_group_id,
    SUM(original_balance) AS original_promise_balance,
    SUM(total_paid) AS total_applied,
    SUM(original_balance - total_paid) AS expected_promise_balance,
    CASE
      WHEN SUM(original_balance - total_paid) = 0 THEN 'K'
      ELSE 'A'
    END AS expected_agreement_status
  FROM term_results
  GROUP BY account_number, ptp_id, ptp_group_id
)

-- Step 5: Output
SELECT
  t.*,
  a.original_promise_balance,
  a.total_applied AS agreement_total_paid,
  a.expected_promise_balance,
  a.expected_agreement_status
FROM term_results t
JOIN agreement_summary a
  ON t.account_number = a.account_number
  AND t.ptp_id = a.ptp_id
ORDER BY t.account_number, t.term_counter;
