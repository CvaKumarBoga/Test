Write a big query as per below description

I have a transaction table fields account number and amount column and PTP agreement table fields account number and remaining amount and PTP id and PTP agreement table fields PTP id and account number and total amount so based on transaction amount need to update amount column in PTP aggreement table and PTP assignment table example 3000 transaction amount and if transaction is > PTP agreement table amount (1500)and PTP arrangement table PTP amount column (1500) need to subtract and remaining 1500 amount against substrate from next record so similarly if 2 transaction records for same account number need to subtract all two transactions amount from all PTP amount from agreement table and assignment table

-- Step 1: Sum total transaction amounts per account
WITH transaction_summary AS (
  SELECT
    account_number,
    SUM(amount) AS total_transaction_amount
  FROM
    transaction_table
  GROUP BY
    account_number
),

-- Step 2: Compute how much to deduct from ptp_agreement_table
ptp_agreement_update AS (
  SELECT
    p.ptp_id,
    p.account_number,
    p.remaining_amount,
    LEAST(p.remaining_amount, t.total_transaction_amount) AS amount_to_deduct,
    -- remaining transaction amount after deduction
    GREATEST(t.total_transaction_amount - p.remaining_amount, 0) AS remaining_txn_after_agreement
  FROM
    ptp_agreement_table p
  JOIN
    transaction_summary t
  ON
    p.account_number = t.account_number
),

-- Step 3: Compute how much to deduct from ptp_assignment_table using the remaining amount
ptp_assignment_update AS (
  SELECT
    pa.ptp_id,
    pa.account_number,
    pa.total_amount,
    LEAST(pa.total_amount, a.remaining_txn_after_agreement) AS amount_to_deduct
  FROM
    ptp_assignment_table pa
  JOIN
    ptp_agreement_update a
  ON
    pa.ptp_id = a.ptp_id
)

-- Final Select to show the updates
SELECT
  'ptp_agreement_table' AS table_name,
  ptp_id,
  account_number,
  remaining_amount AS original_amount,
  remaining_amount - amount_to_deduct AS updated_amount
FROM
  ptp_agreement_update

UNION ALL

SELECT
  'ptp_assignment_table' AS table_name,
  ptp_id,
  account_number,
  total_amount AS original_amount,
  total_amount - amount_to_deduct AS updated_amount
FROM
  ptp_assignment_update;





-- Input: Specific account numbers
WITH transaction_data AS (
  SELECT
    account_number,
    SUM(transaction_amount) AS total_transaction_amount
  FROM
    transaction
  WHERE
    account_number IN ('000004005205201678', '000004005205201679')
  GROUP BY
    account_number
),

arrangement_base AS (
  SELECT
    p.account_number,
    p.ptp_group_id,
    p.ptp_id,
    p.term_counter,
    p.promise_balance,
    p.total_payment_amount,
    p.status AS ptp_status,
    p.term,
    p.remaining_ptp_term_balance,
    t.total_transaction_amount AS total_txn_amt,
    t.total_transaction_amount AS txn_amt_remaining
  FROM
    promise_to_pay_arrangement p
  JOIN
    transaction_data t
  ON
    p.account_number = t.account_number
),

RECURSIVE arrangement_recursive AS (
  -- Anchor: start with lowest term_counter (1)
  SELECT
    account_number,
    ptp_group_id,
    ptp_id,
    term_counter,
    promise_balance,
    total_payment_amount,
    ptp_status,
    term,
    remaining_ptp_term_balance,
    total_txn_amt,
    txn_amt_remaining,
    -- Amount applied in this iteration
    CASE
      WHEN txn_amt_remaining >= remaining_ptp_term_balance THEN remaining_ptp_term_balance
      ELSE txn_amt_remaining
    END AS payment_applied
  FROM
    arrangement_base
  WHERE
    term_counter = 1

  UNION ALL

  -- Recursive step: process the next term_counter + 1
  SELECT
    b.account_number,
    b.ptp_group_id,
    b.ptp_id,
    b.term_counter,
    b.promise_balance,
    b.total_payment_amount,
    b.ptp_status,
    b.term,
    b.remaining_ptp_term_balance,
    r.total_txn_amt,
    
    -- Update remaining txn amount
    CASE
      WHEN r.txn_amt_remaining >= r.remaining_ptp_term_balance THEN r.txn_amt_remaining - r.remaining_ptp_term_balance
      ELSE 0
    END AS txn_amt_remaining,

    -- Compute this recordâ€™s payment
    CASE
      WHEN r.txn_amt_remaining >= r.remaining_ptp_term_balance THEN b.remaining_ptp_term_balance
      ELSE r.txn_amt_remaining
    END AS payment_applied

  FROM
    arrangement_base b
  JOIN
    arrangement_recursive r
  ON
    b.account_number = r.account_number
    AND b.term_counter = r.term_counter + 1
)

-- Final: Expected Arrangement and Agreement Result
, arrangement_result AS (
  SELECT
    account_number,
    ptp_group_id,
    ptp_id,
    term_counter,
    remaining_ptp_term_balance AS original_balance,
    payment_applied,
    remaining_ptp_term_balance - payment_applied AS expected_remaining_balance,
    CASE
      WHEN remaining_ptp_term_balance - payment_applied = 0 THEN 'K'  -- Fully paid
      ELSE ptp_status
    END AS expected_ptp_status
  FROM
    arrangement_recursive
),

agreement_result AS (
  -- Aggregate arrangement data to get agreement-level (Promise Balance) result
  SELECT
    a.account_number,
    SUM(a.remaining_ptp_term_balance) AS original_promise_balance,
    SUM(a.payment_applied) AS total_payment_applied,
    SUM(a.remaining_ptp_term_balance - a.payment_applied) AS expected_promise_balance,
    CASE
      WHEN SUM(a.remaining_ptp_term_balance - a.payment_applied) = 0 THEN 'K'
      ELSE MAX(p.ptp_status)
    END AS expected_agreement_status
  FROM
    arrangement_recursive a
  JOIN
    promise_to_pay_arrangement p
  ON
    a.account_number = p.account_number
    AND a.ptp_group_id = p.ptp_group_id
    AND a.term_counter = p.term_counter
  GROUP BY
    a.account_number
)

-- Final SELECT combining both arrangement and agreement expected results
SELECT
  ar.account_number,
  ar.ptp_group_id,
  ar.ptp_id,
  ar.term_counter,
  ar.original_balance,
  ar.payment_applied,
  ar.expected_remaining_balance,
  ar.expected_ptp_status,
  ag.original_promise_balance,
  ag.total_payment_applied,
  ag.expected_promise_balance,
  ag.expected_agreement_status
FROM
  arrangement_result ar
JOIN
  agreement_result ag
ON
  ar.account_number = ag.account_number
ORDER BY
  ar.account_number,
  ar.term_counter;
